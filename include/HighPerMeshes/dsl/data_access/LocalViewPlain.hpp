// Copyright (c) 2017-2020
//
// Distributed under the MIT Software License
// (See accompanying file LICENSE)

#ifndef DSL_DATAACCESS_LOCALVIEWPLAIN_HPP
#define DSL_DATAACCESS_LOCALVIEWPLAIN_HPP

#include <array>
#include <cassert>
#include <cstdint>
#include <tuple>
#include <type_traits>

#include <HighPerMeshes/auxiliary/ConstexprFor.hpp>
#include <HighPerMeshes/common/DataTypes.hpp>
#include <HighPerMeshes/dsl/meta_programming/util/IsAccessDefinitions.hpp>
#include <HighPerMeshes/dsl/buffers/LocalBuffer.hpp>
#include <HighPerMeshes/dsl/data_access/Dof.hpp>

namespace HPM::internal
{
    using ::HPM::auxiliary::ConstexprFor;
    using ::HPM::dataType::ConstexprArray;
    using ::HPM::dof::GetOffset;

    // Forward declaration.
    class LocalView;

    //!
    //! \brief A version of the local view that translates the `LocalBuffer`s into a plain data type which instead of the `LocalBuffers` stores offsets to some base pointer.
    //!
    class LocalViewPlain
    {
        friend class LocalView;

        //!
        //! \brief Extract the number of `LocalBuffers` in the local view.
        //!
        //! The type of the local view is provided to the `LocalViewPlain` constructor as would be generated by the `LocalView`.
        //! It is a tuple of tuple of arrays.
        //! The outermost tuple is for the elements of the access list (that is, the specified fields and their access patterns).
        //! The innermost tuple holds the arrays of `LocalBuffer`s in all dimensions up to the cell dimension.
        //! The arrays hold the `LocalBuffer`s for all (sub-entities) in all of the different dimensions.
        //!
        //! This function processes any of the innermost tuples of the `LocalView` type.
        //! It collects all extents of arrays of `LocalBuffer`s.
        //! `InvalidLocalBuffers` are sorted out effectively.
        //!
        //! \tparam TupleT the type of the innermost tuple
        //! \tparam Dimension a variadic list of dimensions to be consdered: 0..CellDimension
        //! \param unnamed used for template parameter deduction
        //! \return a `ConstexprArray` holding the number of `LocalBuffers` in each `Dimension` (as non-type template parameters)
        //!
        template <typename TupleT, std::size_t... Dimension>
        static constexpr auto ExtractNumLocalBuffers(std::index_sequence<Dimension...>)
        {
            // We test for '<' as the last tuple element is an integral_constant holding the cell dimension.
            static_assert(sizeof...(Dimension) < std::tuple_size_v<TupleT>, "error: out of range access.");

            // Consider only tuple elements that are not `InvalidLocalBuffers`: they have type `std::array<std::size_t,N>` and we are interested in their sizes `N`.
            constexpr bool IsValid[] = {!std::is_same_v<std::tuple_element_t<Dimension, TupleT>, InvalidLocalBuffer>...};

            // Construct a `ConstexprArray` type with the sizes of the `std::array<std::size_t,N>` elements of the tuple as non-type template parameters.
            // For any tuple element of type `InvalidLocalBuffer`, we use an `std::array<std::size_t,0>` type that has size `0`.
            return ConstexprArray<std::size_t, std::tuple_size_v<std::conditional_t<IsValid[Dimension], std::tuple_element_t<Dimension, TupleT>, std::array<std::size_t, 0>>>...>{};
        }

        //!
        //! \brief A plain data type for storing offsets to some base pointer.
        //!
        //! Meaning of the members:
        //!     - cell_dimension : the dimension of the cell entity
        //!     - num_entries : the number of fields for which offsets are stored
        //!     - size : the size of the `data` member (in units of `unsigned long long` words)
        //!     - byte_size : the total size of the plain type in bytes
        //!     - data : a sequence of `Ã¹nsigned long long` words encoding the orignal `LocalView` type
        //!
        //! Encoding:
        //!     - each entry `<i>` is assigned a contigous block (partition) starting at position `P<i>` inside `data`
        //!     - partitions are divided into a block of meta information and contiguos blocks (starting at position `E<i,d>` inside `data`) containing offsets
        //!       for entities of dimension `d=0..cell_dimension`.
        //!     - `data[0]..data[(num_entries-1)]` : start positions `P<i>` inside `data` (entry partitions).
        //!        -> length: `num_entries`
        //!     - `data[P<i>]..data[(P<i>+cell_dimension)]` : start positions `E<i,d>` inside `data` (entity partitions for dimension `d`).
        //!        -> length: `cell_dimension+1`
        //!     - `data[E<i,d>]` : the number `NO<i,d>` of entities with dimension `d` for which offset values are stored.
        //!     - `data[E<i,d>+1]..data[E<i,d>..NO<i,d>]` : a sequence of offset values for entities with dimension `d`.
        //!
        //! \tparam CellDimension the cell dimension
        //! \tparam NumEntries the number of entries
        //! \tparam NumLocalBuffers the total number of offset values to be stored (one for each `LocalBuffer`)
        //!
        template <std::size_t CellDimension, std::size_t NumEntries, std::size_t NumLocalBuffers>
        class PlainOffset
        {
            // In addition to `NumLocalBuffers`, we need to store for each entry
            //    - `P<i>`
            //    - `E<i,0>..E<i,CellDimension>`
            //    - `NO<i,0>..NO<i,CellDimension>`
            static constexpr std::size_t DataSize = NumEntries * (1 + 2 * (CellDimension + 1)) + NumLocalBuffers;

            friend class ::HPM::internal::LocalViewPlain;

            //!
            //! \brief Collect all offset values in all dimensions for a particular entry.
            //!
            //! The iteration over all dimensions happens inside the function.
            //!
            //! \tparam ListIndex index of the entry (element) in the access list
            //! \tparam AccessListElement the type of the access list element
            //! \tparam MeshT the mesh type
            //! \tparam EntityT the type of the considered entity
            //! \tparam Dimension a variadic list of dimensions to be consdered: 0..CellDimension
            //! \param access the `AccessDefinition` for a particular entry (element)
            //! \param mesh a reference to the mesh
            //! \param entity the considered entity
            //! \param unnamed used for template parameter deduction
            //!
            template <std::size_t ListIndex, typename AccessListElement, typename MeshT, typename EntityT, std::size_t... Dimension>
            void GetOffsetValues(const AccessListElement& access, const MeshT& mesh, const EntityT& entity, std::index_sequence<Dimension...>)
            {
                // If this is the first entry in the list: this function is called from within a variadic function that loops over all entries in the access list.
                if constexpr (ListIndex == 0)
                {
                    // We need to set up the start position of the first partition: there are `NumEntries` many entries.
                    data[0] = NumEntries;
                }

                // Set up a base pointer to this entry's partition.
                assert(ListIndex < DataSize && (data[ListIndex] + CellDimension + 1) <= DataSize);
                unsigned long long* entry = &data[data[ListIndex]];
                // Inside the partition, note the position `E<i,0>` of the first block (entity partition) assigned to entities with dimension 0: there are `CellDimension+1` blocks.
                entry[0] = CellDimension + 1;
                // We use this variable to accumulate on it for the start position of the next block.
                std::size_t entry_size = CellDimension + 1;

                ConstexprFor<0, CellDimension + 1>([&, entity = access.pattern(entity)](const auto D) {
                    // Deduce the dof mask from the access pattern.
                    constexpr std::size_t DofMask[] = {(decltype(access.Dofs)::template At<Dimension>() && (Dimension <= EntityT::Dimension) ? 1 : 0)...};
                    // Set up a base pointer to this entity's block.
                    unsigned long long* slot = &entry[entry[D]];
                    assert(static_cast<std::size_t>(slot - &data[0]) <= DataSize);
                    // The number of offset values stored (the length of the block, excluding `NO<i,d>`).
                    unsigned num_offsets = 0;
                    // Default assignment: the slot is empty.
                    slot[0] = 0;

                    if constexpr (DofMask[D] > 0)
                    {
                        if constexpr (AccessListElement::UseCompileTimeDofs)
                        {
                            // Extract the actual number of dofs from the `DofT` and the dof mask.
                            using DofT = typename AccessListElement::BufferT::DofT;
                            constexpr std::size_t NumDofs = DofT::template At<D>() * DofMask[D];

                            if constexpr (NumDofs > 0)
                            {
                                // Request the (global) indices of all (sub-)entities of the specified `Dimension` (w.r.t. this entity).
                                const auto& entity_indices = entity.GetTopology().template GetIndicesOfEntitiesWithDimension<D>();
                                // We store one offset value for each (sub-)entity.
                                num_offsets = entity_indices.size();
                                // Adapt the size of the slot.
                                slot[0] = num_offsets;

                                assert(static_cast<std::size_t>(slot + (1 + num_offsets) - &data[0]) <= DataSize);
                                for (std::size_t i = 0; i < num_offsets; ++i)
                                {
                                    // Calculate the offset value.
                                    slot[1 + i] = GetOffset<D, DofT>(mesh) + entity_indices[i] * NumDofs;
                                }
                            }
                        }
                        else
                        {
                            // Get the dofs from the access list element.
                            const auto& dofs = access.buffer->GetDofs();
                            const std::size_t num_dofs = dofs.template At<D>() * DofMask[D];

                            if (num_dofs > 0)
                            {
                                // Request the (global) indices of all (sub-)entities of the specified `Dimension` (w.r.t. this entity).
                                const auto& entity_indices = entity.GetTopology().template GetIndicesOfEntitiesWithDimension<D>();
                                // We store one offset value for each (sub-)entity.
                                num_offsets = entity_indices.size();
                                // Adapt the size of the slot.
                                slot[0] = num_offsets;

                                assert(static_cast<std::size_t>(slot + (1 + num_offsets) - &data[0]) <= DataSize);
                                for (std::size_t i = 0; i < num_offsets; ++i)
                                {
                                    // Calculate the offset value.
                                    slot[1 + i] = GetOffset<D>(mesh, dofs) + entity_indices[i] * num_dofs;
                                }
                            }
                        }
                    }

                    // For all iterations except the last one, calculate the start position of the next block (for the entity with one dimension higher).
                    if constexpr ((D + 1) <= CellDimension)
                    {
                        entry[D + 1] = entry[D] + 1 + num_offsets;
                    }

                    // Accumulate the size of this block on the `entry_size` variable.
                    entry_size += (1 + num_offsets);
                });
                // Except for the last list entry, we initialize the start position of the next partition to the value stored for this entry's partition
                // plus the size of this entry's partition.
                if constexpr ((ListIndex + 1) < NumEntries)
                {
                    data[ListIndex + 1] = data[ListIndex] + entry_size;
                }

                // Translate the local start positions `E<i,d>` inside this partition to global indices by shifting their values by
                // the start position of this partition.
                ConstexprFor<0, CellDimension + 1>([this, &entry](const auto D) { entry[D] += data[ListIndex]; });
            }

            //!
            //! \brief Standard constructor.
            //!
            PlainOffset() : cell_dimension(CellDimension), num_entries(NumEntries), size(DataSize), byte_size(2 * sizeof(unsigned) + (2 + DataSize) * sizeof(unsigned long long)) {}

            //!
            //! \brief Construct this `PlainOffset` instance from an access list and an entity instance.
            //!
            //! \tparam AccessListElement a variadic list of the types of the access list elements
            //! \tparam MeshT the mesh type
            //! \tparam EntityT the type of the considered entity
            //! \tparam ListIndex a variadic list of indices used to access the access list
            //! \param access_lost the `AccessDefinition` for a collection of entries
            //! \param mesh a reference to the mesh
            //! \param entity the considered entity
            //! \param unnamed used for template parameter deduction
            //!
            template <typename... AccessListElement, typename MeshT, typename EntityT, std::size_t... ListIndex>
            PlainOffset(const std::tuple<AccessListElement...>& access_list, const MeshT& mesh, const EntityT& entity, std::index_sequence<ListIndex...>)
                : cell_dimension(CellDimension), num_entries(NumEntries), size(DataSize), byte_size(2 * sizeof(unsigned) + (2 + DataSize) * sizeof(unsigned long long))
            {
                (GetOffsetValues<ListIndex>(std::get<ListIndex>(access_list), mesh, entity, std::make_index_sequence<MeshT::CellDimension + 1>{}), ...);
            }

            public:
            // The dimension of the cell.
            const unsigned cell_dimension;
            // The number of tuple elements in the original local view.
            const unsigned num_entries;
            // The size of the flexible array member.
            const unsigned long long size;
            // The size of this data structure.
            const unsigned long long byte_size;
            // Encoded offset values (see description above).
            unsigned long long data[std::max(1UL, DataSize)];
        };

        //!
        //! \brief Create a local view to the dofs of some entity according to some access list.
        //!
        //! This function translates the `LocalBuffer` version of the local view into a plain data type which instead of the `LocalBuffers` stores offsets to some base pointer.
        //!
        //! \tparam TupleT the type created by the `LocalView`
        //! \tparam AccessList the `AccessDefinition` type for a collection of fields
        //! \tparam MeshT the type of the mesh
        //! \tparam EntityT the type of the considered entity
        //! \param access_list the `AccessDefinition` for a collection of fields
        //! \param mesh a reference to the mesh
        //! \param entity the considered entity
        //! \return a plain data type which instead of the `LocalBuffers` stores offsets to some base pointer
        //!
        template <typename TupleT, typename AccessList, typename MeshT, typename EntityT, std::size_t... TupleIndex>
        static auto Create(const AccessList& access_list, const MeshT& mesh, const EntityT& entity, std::index_sequence<TupleIndex...>)
        {
            // Determine for each tuple element its size.
            constexpr std::size_t TupleSizes[] = {std::tuple_size_v<std::tuple_element_t<TupleIndex, TupleT>>...};

            // Determine the cell dimension for all tuple elements: it is the last element in each TupleT element, and must be the same for all tuple elements.
            constexpr std::size_t Dimensions[] = {std::tuple_element_t<TupleSizes[TupleIndex] - 1, std::tuple_element_t<TupleIndex, TupleT>>::value...};
            constexpr std::size_t Dimension = Dimensions[0];
            static_assert(((Dimensions[TupleIndex] - Dimension) + ...) == 0, "error: access list elements have different dimensions.");

            // Get the size of the data access list.
            constexpr std::size_t AccessListSize = std::tuple_size_v<AccessList>;

            // Determine for all tuple elements the total number of `LocalBuffer`s: use the `Sum()` function.
            constexpr ConstexprArray<std::size_t, ExtractNumLocalBuffers<std::tuple_element_t<TupleIndex, TupleT>>(std::make_index_sequence<TupleSizes[TupleIndex] - 1>{}).Sum()...> NumLocalBuffers{};

            // Define the plain data type that will hold all offsets.
            constexpr std::size_t NumOffsetValues = NumLocalBuffers.Sum();
            using OffsetRecord = PlainOffset<Dimension, AccessListSize, NumOffsetValues>;

            return OffsetRecord(access_list, mesh, entity, std::make_index_sequence<AccessListSize>{});
        }

        //!
        //! \brief Create a local view to the dofs of some entity according to some access list.
        //!
        //! This function calls the create function together with an index sequence for tuple element processing.
        //!
        //! \tparam TupleT the type created by the `LocalView`
        //! \tparam AccessList the `AccessDefinition` type for a collection of fields
        //! \tparam MeshT the type of the mesh
        //! \tparam EntityT the type of the considered entity
        //! \param access_list the `AccessDefinition` for a collection of fields
        //! \param mesh a reference to the mesh
        //! \param entity the considered entity
        //! \return a plain data type which instead of the `LocalBuffers` stores offsets to some base pointer
        //!
        template <typename TupleT, typename AccessList, typename MeshT, typename EntityT>
        static auto Create(const AccessList& access_list, const MeshT& mesh, const EntityT& entity)
        {
            static_assert(IsAccessDefinitions<AccessList>);

            constexpr std::size_t AccessListSize = std::tuple_size_v<AccessList>;
            constexpr std::size_t TupleSize = std::tuple_size_v<TupleT>;
            static_assert(AccessListSize == TupleSize, "error: tuple sizes are different.");

            if constexpr (AccessListSize > 0)
            {
                return Create<TupleT>(access_list, mesh, entity, std::make_index_sequence<TupleSize>{});
            }
            else
            {
                return PlainOffset<0, 0, 0>{};
            }
        }
    };
} // namespace HPM::internal

#endif